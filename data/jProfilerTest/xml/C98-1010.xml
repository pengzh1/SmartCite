<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 D:\Work\grobid-master\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.5" ident="GROBID" when="2019-07-07T11:04+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Memory-Based Approach to Learning Shallow Natural Language Patterns</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shlomo</forename><surname>Argamon</surname></persName>
							<email>argamon@biu.ac.±1</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Ilan University</orgName>
								<address>
									<postCode>52900</postCode>
									<settlement>Ramat Gan</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ido</forename><surname>Dagan</surname></persName>
							<email>dagan@biu.ac.±1</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Ilan University</orgName>
								<address>
									<postCode>52900</postCode>
									<settlement>Ramat Gan</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Krymolowski</surname></persName>
							<email>yuvalk@cs@biu.ac.±1</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Ilan University</orgName>
								<address>
									<postCode>52900</postCode>
									<settlement>Ramat Gan</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Memory-Based Approach to Learning Shallow Natural Language Patterns</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract</head><p>Recognizing shallow linguistic patterns, such as basic syntactic relationships between words, is a com~ mon task in applied natural language and text pro-(:essing. Tile common practice for approaching this task is by tedious manual definition of possible pattern structures, often in the h)rm of regular expressions or finite automata. This paper presents a novel memory-based learning method that recognizes shallow patterns in new text based on a bracketed training corpus. The training data are stored as-is, in efficient suttix-tree data structures. Generalization is performed on-line at recognition time by comparing subsequences of the new text to positive and negative evidence in the corIms. This way, no information in tit(; training is lost, as can happen in other learning systems that construct a single generalized model at the time of training. The paper presents experimental results for recognizing noun phrase, subject-verb and verb-object patterns in l!]nglish. Since the learning approach enables easy porting to new domains, we plan to apply it to syntactic patterns in other languages and to sub-language patterns for information extraction.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Identifying local patterns of syntactic sequences and relationships is a fundamental task in natural language processing (NLP). Such patterns may correspond to syntactic phrases, like noun phrases, or to pairs of words that participate in a syntactic relationship, like the heads of a verb-object relation. Such patterns have been found useful in various application areas, including information extraction, text summarization, and bilingual alignment. Syntactic patterns are useful also for many basic computational linguistic tasks, such as statistical word similarity and various disambiguation problems.</p><p>One approach for detecting syntactic patterns is to obtain a full parse of a sentence and then extract the required patterns. However, obtaining a complete parse tree for a sentence is difficult in many cases, and may not be necessary at all for identifying most instances of local syntactic patterns.</p><p>An alternative approach is to avoid the complexity of fllll parsing and instead to rely only on local information. A variety of methods have been developed within this framework, known as shallow parsing, chunking, local parsing etc. (e.g., <ref type="bibr" target="#b0">(Abney, 1991;</ref><ref type="bibr" target="#b10">Greffenstette, 1993)</ref>). These works have shown that it is possible to identify most instances of local syntactic patterns by rules that examine only the pattern itself and its nearby context;. ()ften, the rules are applied to sentences that were tagged by partof-speech (POS) and are phrased by some form of regular expressions or finite state automata.</p><p>Manual writing of local syntactic rules has become a common practice for many applications. Itowcver, writing rules is often tedious and time consuming. Furthermore, extending the rules to different languages or sub-language domains can require substantial resources and expertise that are often not available. As in many areas of NLP, a learning approach is appealing. Surprisingly, though, rather little work has been devoted to learning local syntactic patterns, mostly noun phrases <ref type="bibr" target="#b11">(Ramshaw and Marcus, 1995;</ref><ref type="bibr" target="#b17">Vilain and Day, 1996)</ref>. This paper presents a novel general learning approach for recognizing local sequential patterns, that may be perceived as failing within the memorybased learning paradigm. The method utilizes a part-of-speech tagged training corpus in which all instances of the target pattern are marked (bracketed). The training data are stored as-is in suffix-tree data structures, which enable linear time searching for subsequences in the corpus.</p><p>The memory-based nature of the presented algorithm stems from its deduction strategy: a new instance of tile target pattern is recognized by examining the raw training corpus, searching for positive and negative evidence with respect to the given test sequence. No model is created for the training corpus, and tile raw examples are not converted to any other representation.</p><p>Consider the following example 1. Suppose we 1We use here the POS tags: DT = determiner, ADJ = adjective, ADV = adverb, C0RJ = conjunction, VB--verb, PP=preposition, NN = singular noun, and NNP = plural noun. want to decide whether the candidate sequence DT ADJ ADJ NN NNP is a noun phrase (NP) by comparing it to the training corpus. A good match would be if the entire sequence appears as-is several times in the corpus. However, due to data sparseness, an exact match cannot always be expected.</p><p>A somewhat weaker match may be obtained if we consider sub-parts of the candidate sequence (called tiles). For example, suppose the corpus contains noun phrase instances with the following structures:</p><formula xml:id="formula_0">(I) DT ADJ ADJ NN NN (2) DT ADJ NN NNP</formula><p>The first structure provides positive evidence that the sequence "DT ADJ ADJ NN" is a possible NP prefix while the second structure provides evidence for "ADJ NN NNP" being an NP suffix. Together, these two training instances provide positive evidence that covers the entire candidate. Considering evidence for sub-parts of the pattern enables us to generalize over the exact structures that are present in the corpus. Similarly, we also consider the negative evidence for such sub-parts by noting where they occur in the corpus without being a corresponding part of a target instance.</p><p>The proposed method, as described in detail in the next section, formalizes this type of reasoning. It searches specialized data structures for both positive and negative evidence for sub-parts of the candidate structure, and considers additional factors such as context and evidence overlap. Section 3 presents experimental results for three target syntactic patterns in English, and Section 4 describes related work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>The Algorithm</p><p>The input to the Memory-Based Sequence Learning (MBSL) algorithm is a sentence represented as a sequence of POS tags, and its output is a bracketed sentence, indicating which subsequences of the sentence are to be considered instances of the target pattern (target instances). MBSL determines the bracketing by first considering each subsequence of the sentence as a candidate to be a target instance.</p><p>It computes a score for each candidate by comparing it to the training corpus, which consists of a set of pre-bracketed sentences. The algorithm then finds a consistent bracketing for the input sentence, giving preference to high scoring subsequences. In the remainder of this section we describe tile scoring and bracketing methods in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Scoring candidates</head><p>We first describe the mechanism for scoring an individual candidate. The input is a candidate subsequence, along with its context, i.e., the other tags in the input sentence. The method is presented at two levels: a general memory-based learning schema and a particular instantiation of it. Further instantiations of the schema are expected in future work. The idea of the MBSL scoring algorithm is to construct a tiling of subsequences of a situated candidate which covers the entire candidate. We consider as tiles subsequences of the situated candidate which contain a bracket. (We thus consider only tiles within or adjacent to the candidate that also include a candidate boundary.)</p><p>Each tile is assigned a score based on its occurrence in the training memory. Since brackets correspond to the boundaries of potential target instances, it is important to consider how the bracket positions in the tile correspond to those in the training memory.</p><p>For example, consider the training sentence</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[ NN ] VB [ ADJ NN NN ] ADV PP [ NN ]</head><p>We may now examine the occurrence in this sentence of several possible tiles: The positive evidence for a tile is measured by its positive count, tile number of times the tile (ineluding brackets) occurs in the training memory with corresponding brackets. Similarly, the negative evidence for a tile is measured by its negative count, the number of times that the POS sequence of the tile occurs in the training memory with noncorresponding brackets (either brackets in the training where they do not occur in the tile, or vice versa).</p><formula xml:id="formula_1">VB</formula><p>The total count of a tile is its positive count plus its negative count, that is, the total count of the POS sequence of the tile, regardless of bracket position.</p><p>The score f(t) of a tile t is a function of its positive and negative counts. The overall score of a situated candidate is gen-(.'rally a function of the scores of all the tiles for the candidate, as well as the relations between the tiles' positions. These relations include tile adjacency, overlap between tiles, the amount of context in a tile, and so on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">An instantiation of the MBSL schema</head><p>In our instantiation of the MBSL schema, we define the score f(t) of a tile t as the ratio of its positive count pos(t) ~md its total count total(t):</p><formula xml:id="formula_2">1 if~&gt;0 total(t) f(t)= 0 otherwise</formula><p>for a predefined threshold 0. Tiles with a score of 1, and so with sufficient positive evidence, are called matching tiles.</p><p>Each matching tile gives supporting evidence that a part of the candidate, can be a part of a target instance. In order to combine this evidence, we try to ('over the entire candidate by a set of matching tiles, with no gaps. Such a covering constitutes evidence that the entire candidate is a target instance. For example, consider the matching tiles shown for the candidate in <ref type="figure" target="#fig_1">Figure 1</ref>. The set of matching tiles 2, 4, and 5 covers tile candidate, as does the set of tiles ] and 5. Also note that tile 1 constitutes a cover on its own.</p><p>To make this precise, we first say that a tile T1</p><p>connects to a tile T.e if (i) ~/) starts after Tt starts,</p><p>(ii) there is no gap between the end of T1 and the .~tart of T.2 (there may be some overlap), and (iii) T2 ends after T1 (neither tile includes the other). For example, tiles 2 and 4 in the figure connect, while tiles 2 and 5 do not, and neither do tiles 1 and 4 (since tile 1 includes tile 4 as a subsequence).</p><p>A cover for a situated candidate (: is a sequence of matching tiles which collectively cover the entire candidate, including the boundary brackets, and possibly some context, such that each tile connects to the following one. A cover thus provides positive evidence for the entire sequence of tags in the candidate. The set of all the covers for a candidate smnmarizes all of the evidence for the candidate being a target instance. We therefore compute tile score of a candidate as a function of some statistics of the set of all its covm's. For example, if a candidate has many different covers, it; is more likely to be a target instance, since many different pieces of evidence can be brought to bear.</p><p>We have empirically found several statistics of the cover set to be useful. These include, for' each cover, the number of tiles it contains, the total number of context tags it contains, and the number of positions which more than one tile covers (the amount of overlap). We thus compute, for the set of all covers of a candidate c, the * Total number of different covers, num(c),</p><p>• Minimum number of matches in any cover, minsize(e),</p><p>• Maximum aInount of context in any <ref type="bibr">(:over, maxcontext(c)</ref>, and</p><p>• Maximmn total overlap between tiles for any cover, maxoverlap(c).</p><p>Each of these items gives an indication regarding tile overall strength of the cover-based evidence for tile candidate.</p><p>The score of the candidate is a linear flmction of its statistics: If candidate c has no covers, we set f(e) = 0. Note that minsize is weighted negatively, since a cover with fewer tiles provides stronger evidence for the candidate.</p><p>In the current implementation, the weights were chosen so as to give a lexicographic ordering, preferring first candidates with more covers, then those with covers containing fewer tiles, then those with larger contexts, and finally, when all else is equal, preferring candidates with more overlap between tiles. We plan to investigate in the future a datadriven al)proach (based on the Winnow algorithm) for optimal selection and weighting of statistical features of the score.</p><p>We compute a candidate's statistics efficiently by performing a depth-first traversal of the cover graph of the candidate. The cover graph is a directed acyclic graph (DAG) whose nodes represent matching tiles of the candidate, such that an arc exists between nodes n and n', if tile n connects to n'. A special start node is added as the root of the DAG, that connects to all of the nodes (tiles) that contain an open bracket. There is a cover corresponding to each path from the start node to a node (tile) that contains a close bracket. Thus the statistics of all the covers m W be efficiently computed by traversing the cover graph. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Searching the training memory</head><p>The MBSL scoring algorithm searches the training corpus for each subsequence of the sentence in order to find matching tiles. Implementing this search efficiently is therefore of prime importance. We do so by encoding the training corpus using suffix trees <ref type="bibr" target="#b7">(Edward and McCreight, 1976)</ref>, which provide string searching in time which is linear in the length of the searched string. Inspired by <ref type="bibr" target="#b13">Satta (1997)</ref>, we build two suffix trees for retrieving the positive and total counts for a tile. The first suffix tree holds all pattern instances from the training corpus surrounded by bracket symbols and a fixed amount of context. Searching a given tile (which includes a bracket symbol) in this tree yields the positive count for the tile. The second suffix tree holds an unbracketed version of the entire training corpus. This tree is used for searching the POS sequence of a tile, with brackets omitted, yielding the total count for the tile (recall that the negative count is the difference between the total and positive counts).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Selecting candidates</head><p>After the above procedure, each situated candidate is assigned a score. In order to select a bracketing for the input sentence, we assume that target instances are non-overlapping (this is usually the case for the types of patterns with which we experimented). We use a simple constraint propagation algorithm that finds the best choice of non-overlapping candidates in an input sentence:   <ref type="table">Table 2</ref>: Distribution of pattern lengths, total number of patterns and average length in the training data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Data</head><p>We have tested our algorithm in recognizing three syntactic patterns: noun phrase sequences (NP), verb-object (VO), and subject-verb (SV) relations. The NP patterns were delimited by ' <ref type="bibr">[' and ']</ref>' symbols at the borders of the phrase. For VO patterns, we have put the starting delimiter before tile main verb and the ending delimiter after the object head, thus covering the whole noun phrase comprising the object; for example: We used a similar policy for SV patterns, defining the start of the pattern at the start of the subject noun phrase and the end at the first verb encountered (not including auxiliaries and modals); for example:</p><formula xml:id="formula_3">• .</formula><p>.  The subject and object noun-phrase borders were those specified by the atmotators, phrases which contain conjunctions or apl)ositives were not further analyzed. The training and testing data were derived from the Penn ~li'eeBank. We used the NP data prepared by <ref type="bibr">Ramshaw and Mm'cus (1995)</ref>, hereafter RM95. The SV and VO data were obtained using T (TreeBank's search script language) scripts. "~ <ref type="table">Table 1</ref> summarizes the sizes of the training and test data sets and the nmnber of examples in each.</p><p>The T scripts did not attempt to match dependencies over very complex structures, since we are concerned with shallow, or local, patterns. <ref type="table">Table 2</ref> shows the distribution of pattern length in the train data. We also did not attempt to extract passivevoice VO relations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Testing Methodology</head><p>The test procedure has two parameters: (a) maxinmm context size of a candidate, which limits what queries are performed on the memory, and (b) the threshold 0 used tbr establishing a matching tile, which determines how to make use of the query resuits.</p><p>Recall and precision figures were obtained for various parameter values. <ref type="bibr">FZ (van Rijsbergen, 1979)</ref>, a common measure in information retrieval, was used We use fl = 1 which gives no preference to either recall or precision. <ref type="table" target="#tab_6">Table 3</ref> summarizes the optimal parameter settings and results for NP, VO, and SV on the test set. In order to find the optimal values of the context size and threshold, we tried 0.1 &lt; 0 &lt; 0.95, and maximum context sizes of 1,2, and 3. Our experiments used 5-fold cross-validation on the training data to determine the optimal parameter settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Results</head><p>In experimenting with the maximum context size parameter, we found that the difference between the values of F~ for context sizes of 2 and 3 is less than 0.5% for the optimal threshold. Scores for a context size of 1 yielded F~ values smaller by more than 1% than the values for the larger contexts. <ref type="figure" target="#fig_4">Figure 2</ref> shows recall/precision curves for the three data sets, obtained by varying 0 while keeping the maximum context size at its optimal value. The difference between Fr~=l values for different thresholds was always less than 2%.</p><p>Performance may be measured also on a word-by word basis, counting as a success any word which was identified correctly as being part of the target pattern. That method was empIoyed, along with recall/precision, by RM95. We preferred to measure performance by recall and precision for complete patterns. Most errors involved identifications of slightly shifted, shorter or longer sequences. Given a pattern consisting of five words, for example, identifying only a four-word portion of this pattern would yield both a recall and precision errors. Tagassignment scoring, on the other hand, will give it a score of 80%. We hold the view that such an identification is an error, rather than a partial success.</p><p>We used the datasets created by RM95 for NP learning; their results are shown in <ref type="table" target="#tab_6">Table 3</ref>. 3 The F~ difference is small (0.4%), yet they use a richer feature set, which incorporates lexical information as well. The method of Ramshaw and Marcus makes a decision per word, relying on predefined rule templates. The method presented here makes decisions on sequences and uses sequences as its memory, thereby attaining a dynamic perspective of the 3Notice that our results, as well as those we cite from RM95, pertains to a training set of 229,000 words. RM95 report also results for a larger training set, of 950,000 words, for which recall/precision is 93.5%/93.1%, correspondingly (FB=93.3%). Our system needs to be further optimized in order to handle that amount of data, though our major concern in future work is to reduce the overall amount of labeled training data.   pattern structure. We aim to incorporate lexical information as well in the fllture, it is still unclear whether that will improve the results. <ref type="figure" target="#fig_6">Figure 3</ref> shows the learning curves by amount of training examples and number of words in the training data, for particular parameter settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4</head><p>Related Work</p><p>Two previous methods for learning local syntactic patterns follow the transformation-based paradigm introduced by <ref type="bibr" target="#b3">Brill (1992)</ref>. <ref type="bibr" target="#b17">Vilain and Day (1996)</ref> identify (and classify) name phrases such as company names, locations, etc. <ref type="bibr" target="#b11">Ramshaw and Marcus (1995)</ref> detect noun phrases, by classifying each word as being inside a phrase, outside or on the boundary between phrases. Finite state machines (FSMs) are a natural formalism for learning linear sequences. It was used for learning linguistic structures other than shallow syntax. <ref type="bibr" target="#b9">Gold (1978)</ref> showed that learning regular languages from positive examples is undecidable in the limit. Recently, however, several learning methods have been proposed for restricted classes of FSM. OSTIA (Onward Subsequential Transducer Inference Algorithm; Oncina, Gareia, and Vidal 1993), learns a subsequential transducer in the limit. This algorithm was used for natural-language tasks by <ref type="bibr">Vilar, Marzal, and Vidal (1994)</ref> for learning translation of a limited-domain language, as well as by <ref type="bibr" target="#b8">Gildea and Jurafsky (1994)</ref> for learning phonological rules. <ref type="bibr" target="#b1">Ahonen et al. (1994)</ref> describe an algorithm for learning (k,h)-contextual regular languages, which they use for learning the structure of SGML documents.</p><p>Apart from deterministic FSMs, there are a number of algorithms for learning stochastic models, eg., <ref type="bibr" target="#b15">(Stolcke and Omohundro, 1992;</ref><ref type="bibr">Carrasco and Oncina, 1994;</ref><ref type="bibr" target="#b12">Ron et al., 1995)</ref>. These algorithms differ mainly by their state-merging strategies, used for generalizing from the training data.</p><p>A major difference between the abovementioned learning methods and our memory-based approach is that the former employ generalized models that were created at training time while the latter uses the training corpus as-is and generalizes only at recognition time.</p><p>Much work aimed at learning models for full parsing, i.e., learning hierarchical structures. We refer here only to the DOP (Data Oriented Parsing) method <ref type="bibr" target="#b2">(Bod, 1992)</ref> which, like the present work, is a memory-based approach. This method constructs parse alternatives for a sentence based on combinations of subtrees in the training corpus. The MBSL approach may be viewed as a linear analogy to DOP in that it constructs a cover for a candidate based on subsequences of training instances.</p><p>Other implementations of the memory-based paradigm for NLP tasks include <ref type="bibr" target="#b6">Daelemans et al. (1996)</ref>, for POS tagging; <ref type="bibr" target="#b4">Cardie (1993)</ref>, for syntactic and semantic tagging; and <ref type="bibr" target="#b14">Stanfill and Waltz (1986)</ref>, for word pronunciation. In all these works, examples are represented as sets of features and the deduction is carried out by finding the most similar eases. The method presented here is radically different in that it makes use of the raw sequential form of the data, and generalizes by reconstructing test examples from different pieces of the training data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions</head><p>We have presented a novel general schema and a particular instantiation of it for learning sequential patterns. Applying the method to three syntactic patterns in English yielded positive results, suggesting its applicability for recognizing local linguistic patterns. In future work we plan to investigate a datadriven approach for optimal selection and weighting of statistical features of candidate scores, as well as to apply the method to syntactic patterns of Hebrew and to domain-specific t)atterns for information extraction.</p><p>6 acknowledgements</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>[ ADJ NN occurs positively in the sentence, and NN NN ] ADV also occurs positively, while NN [NN ADV occurs negatively in the training sen- tence, since the bracket does not correspond.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A candidate subsequence with some of its context, and 5 matching tiles found in the training corpus.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>f(c) = (~num(c) -flminsize(c)+ 7 maxeontext (c) + 6 maxoverlap(c)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 .</head><label>1</label><figDesc>Examine each situated candidate c with f(c) &gt; 0, in descending order of f(c): (a) Add c's brackets to the sentence; (b) Remove all situated candidates overlapping with c which have not yet been examined.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Recall-Precision curves for NP, VO, and SV; 0.1 &lt; 0 &lt; 0.99</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>http://www.cs.biu.ac.il/~yuvalk/MBSL.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Learning curves for NP, VO, and SV by number of examples (left) and words (right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head></head><label></label><figDesc>situated candidates. A situated candidate is a sen- tence containing one pair of brackets, indicating a candidate to be a target instance. The portion of the sentence between the brackets is the candidate (as above), while the portion before and after the candidate is its context. (Although we describe the algorithm here for the general case of unlimited con- text, for computational reasons our implementation only considers a limited amount of context on either side of the candidate.) This subsection describes how to compute the score of a situated candidate from the training corpus.</figDesc><table>2.1.1 
The general MBSL schema 
The MBSL scoring algorithm works by considering 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="true"><head>Table 3 :</head><label>3</label><figDesc>Results with optimal parameter settings for context size and threshold, and breakeven points. The last line shows the results of Ramshaw and Marcus (1995) (recognizing NP's) with the same train/test data. The optimal parameters were obtained by 5-fold cross-validation.</figDesc><table>90 

85 

7 

80 

/ 
/ 
/ 

/ 
NP. 0~0.7 Con.=~ 

/.f1,~ .jji 

// 
sv. 0=o.1~ Con.=3 
¢ 
/' 

/ 

90 

85 

80 

vo, 0=03 
Con.=2 

0 
20000 
40000 
Hxainples 

/ 
NIL 0=07 Con,=2 

I 

_ _.~ 

sv, 0=06 Con=3 
.~'~" 

I 
/" 
/ 
/ 
¢ 
/ 

/ / 

I/ 

i ] 

i 

i/' 

0 
100000 
200000 
300000 
400000 
Words 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The authors wish to thank Yoram Singer for his collaboration in an earlier phase of this research project, and Giorgio Satta for helpful discussions. We aiso thank the anonymous reviewers for their instructive conunents. This research was supported in part by grant 498/95-1 from the Israel Science l,'om:dation, and by grant 8560296 from the Israeli Ministry of Science.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Parsing by chunks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Abney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principle-Based Parsing: Computation and Psycholinguistics</title>
		<editor>R. C. Berwick, S. P. Abney, and C. Tenny</editor>
		<meeting><address><addrLine>Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="257" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Forming grmnmars fox&apos; structured docmnents: An application of grammatical inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ahonen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Nikunen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Grammatical Inference and Applications (ICGI-9~)</title>
		<editor>R. C. Carrasco and J. Oncina</editor>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="153" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A computational model of language performance: Data oriented parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bod</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Coling</title>
		<meeting><address><addrLine>Nantes, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="855" to="859" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A simple rule-based part of speech tagger</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Brill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. of the DARPA Workshop on Speech and Natural Language</title>
		<meeting>of the DARPA Workshop on Speech and Natural Language</meeting>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A case-based approach to knowledge acquisition for domain-specific sentence analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cardie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th National Conference on Artificial Intelligence</title>
		<meeting>the 11th National Conference on Artificial Intelligence<address><addrLine>Menlo Park, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1993-07" />
			<biblScope unit="volume">798</biblScope>
			<biblScope unit="page">803</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Learning stochastic regular grammars by means of a state merging method</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">C</forename><surname>Carrasco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Oneina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Grammatical Inference and Applications (ICGI-9J)</title>
		<editor>R. C. Carrasco and J. Oncina</editor>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="139" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Mbt: A memory-based part of speech tagger generator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Daelemans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zavrel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Berck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gillis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth Workshop on Very Large Corpora</title>
		<meeting>the Fourth Workshop on Very Large Corpora</meeting>
		<imprint>
			<publisher>ACL SIGDAT</publisher>
			<date type="published" when="1996" />
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">27</biblScope>
		</imprint>
	</monogr>
	<note>Eva Ejerhed and Ido Dagan</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">spaceeconomical suffix tree construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Edward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mccreight</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="262" to="272" />
			<date type="published" when="1976-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Automatic induction of finite state transducers for simple phonological rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gildea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Jurafsky</surname></persName>
		</author>
		<idno>TR-94-052</idno>
	</analytic>
	<monogr>
		<title level="j">International Computer Science Institute</title>
		<imprint>
			<date type="published" when="1994-10" />
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Complexity of atttomaton identification front given data. Information and Control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gold</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978" />
			<biblScope unit="volume">37</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Evaluation techniques for automatic semanti(: extraction: Comparing syntactic and window based approaches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><surname>Greffenstette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A CL Workshop on Acquisition of Lexieal Knowledge From Text</title>
		<imprint>
			<date type="published" when="1993-06" />
		</imprint>
		<respStmt>
			<orgName>Ohio State University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">~li~xt chunking using transformation-based learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Ramshaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Marcus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Workshop on Very Large Corpora</title>
		<meeting>the Third Workshop on Very Large Corpora</meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the learnability and usage of acyclic probabilistic finite automata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Singer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Tishby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Annual Conferencc on Computational Learning 7&apos;hcory (COLT&apos;95)</title>
		<meeting>the 8th Annual Conferencc on Computational Learning 7&apos;hcory (COLT&apos;95)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995-07" />
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">String transformation learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Satta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACL/EACL Annual Meeting</title>
		<meeting>of the ACL/EACL Annual Meeting<address><addrLine>Madrid, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-07" />
			<biblScope unit="page" from="444" to="451" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Toward memorybased reasoning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stanfill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Waltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1213" to="1228" />
			<date type="published" when="1986-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Hidden markov model induction by bayesian model merging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Stolcke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Omohundro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Neural Information Pro~ cessing Systems 5 (NIPS-5)</title>
		<meeting>Neural Information Pro~ cessing Systems 5 (NIPS-5)</meeting>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Van Rijsbergen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Retrieval. Buttersworth</title>
		<imprint>
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Finite-state phrase parsing by rule sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Vilain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Day</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pwc. of COLING</title>
		<meeting><address><addrLine>Copenhagen, Denmark</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
